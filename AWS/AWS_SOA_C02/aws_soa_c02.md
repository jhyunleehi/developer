### 질문 #1주제 1
한 회사에는 애플리케이션 로드 밸런서 뒤의 Amazon EC2 인스턴스에서 실행되는 지옥의 웹 애플리케이션이 있습니다. 

인스턴스는 단일 가용성 영역의 Amazon EC2 자동 확장 그룹에서 실행됩니다. SysOps 관리자는 애플리케이션을 고가용성으로 만들어야 합니다.
SysOps 관리자는 이 요구 사항을 충족하기 위해 어떤 조치를 취해야 합니까?

A. 최대 사용 시 필요한 용량을 충족시키기 위해 자동 크기 조정 그룹의 최대 인스턴스 수를 늘립니다.
B. 최대 사용 시 필요한 용량을 충족시키기 위해 자동 크기 조정 그룹의 최소 인스턴스 수를 늘립니다.
C. 동일한 AWS 지역의 두 번째 가용성 영역에서 새 인스턴스를 시작하도록 자동 크기 조정 그룹을 업데이트합니다. 가장 많이 투표된
D. 두 번째 AWS 지역의 가용성 영역에서 새 인스턴스를 시작하도록 자동 크기 조정 그룹을 업데이트합니다.

정답: C. 동일한 AWS 지역의 두 번째 가용성 영역에서 새 인스턴스를 시작하도록 자동 크기 조정 그룹을 업데이트합니다.
이유:
고가용성을 보장하려면 애플리케이션이 여러 가용성 영역(AZ)에 걸쳐 배포되어야 합니다. 이렇게 하면 한 가용성 영역에서 장애가 발생해도 애플리케이션은 다른 가용성 영역에서 계속 실행될 수 있습니다.
자동 크기 조정 그룹에 두 번째 가용성 영역을 추가하면, 여러 가용성 영역에 걸쳐 인스턴스를 배포할 수 있어 가용성과 내구성이 크게 향상됩니다.
AWS 지역 내 여러 가용성 영역을 사용하는 것이 고가용성 아키텍처를 구현하는 표준 방법입니다.
다른 옵션들은 다음과 같은 이유로 적합하지 않습니다:

A와 B: 최대 또는 최소 인스턴스 수를 늘리는 것은 단일 가용성 영역 내에서만 작동하므로, 고가용성을 보장하지 못합니다. 장애가 발생하면 해당 영역의 모든 인스턴스가 중단될 수 있습니다.
D: 두 번째 AWS 지역으로 확장하는 것은 비용이 증가할 뿐만 아니라, 응답 지연 시간이 증가할 수 있습니다. 또한 동일한 AWS 지역 내 여러 가용성 영역을 사용하면 더 효율적이고 표준적인 고가용성 구성을 제공할 수 있습니다.


### 질문 #2주제 1
한 회사가 Auto Scaling 그룹에서 실행되는 여러 Amazon EC2 인스턴스에 웹사이트를 호스팅합니다. 

사용자는 매주 주말 오후 6시부터 오후 11시 사이의 피크 타임에 느린 응답을 보고합니다. SysOps 관리자는 이러한 피크 타임에 성능을 개선하기 위한 솔루션을 구현해야 합니다.
이러한 요구 사항을 충족하는 가장 운영 효율적인 솔루션은 무엇입니까?

A. 피크 시간 전에 원하는 용량을 늘리기 위해 AWS Lambda 함수를 호출하는 예약된 Amazon EventBridge(Amazon CloudWatch Events) 규칙을 생성합니다.
B. 피크 시간 전후에 원하는 용량을 변경하기 위한 반복 옵션을 사용하여 예약된 확장 작업을 구성합니다. 가장 많이 투표된
C. 메모리 사용률이 70%를 넘을 경우 더 많은 인스턴스를 추가하는 대상 추적 확장 정책을 만듭니다.
D. 자동 크기 조정 그룹의 쿨다운 기간을 구성하여 피크 시간 전후에 원하는 용량을 수정합니다.

정답: B. 피크 시간 전후에 원하는 용량을 변경하기 위한 반복 옵션을 사용하여 예약된 확장 작업을 구성합니다.
이유:
예약된 확장 작업을 통해 피크 시간 전에 인스턴스 용량을 미리 늘리고, 피크 시간이 끝난 후 용량을 줄일 수 있습니다. 이렇게 하면 사용량 패턴에 따라 EC2 인스턴스의 수를 자동으로 조정할 수 있어 피크 타임 동안의 성능을 보장하면서도 비용을 효율적으로 관리할 수 있습니다.
반복 옵션을 사용하면 매주 주말 오후 6시부터 오후 11시 사이에 자동으로 확장 및 축소 작업을 실행할 수 있습니다. 이는 시스템을 수동으로 관리할 필요 없이 성능을 개선하는 운영 효율적인 방법입니다.
다른 옵션들은 다음과 같은 이유로 적합하지 않습니다:

A: Lambda 함수와 EventBridge 규칙을 사용하는 것은 가능하지만, 예약된 확장 작업을 구성하는 것보다 복잡하며 운영 효율성이 떨어집니다.
C: 대상 추적 확장 정책은 실시간으로 확장하지만, 피크 시간에 대한 사전 대비 없이 메모리 사용률이 높아졌을 때만 반응할 수 있어 즉각적인 성능 개선이 어렵습니다.
D: 쿨다운 기간은 인스턴스 수를 확장 또는 축소한 후에 추가 작업을 지연시키기 위한 설정으로, 피크 시간 전에 미리 확장하는 데는 적합하지 않습니다.


### 질문 #3주제 1
한 회사가 Application Load Balancer(ALB) 뒤의 Amazon EC2 인스턴스에서 웹사이트를 운영하고 있습니다. 

이 회사는 Amazon CloudFront 배포를 구성하고 ALB를 원점으로 설정했습니다. 이 회사는 모든 트래픽을 CloudFront 배포를 통해 보내기 위해 Amazon Route 53 CNAME 레코드를 만들었습니다. 의도치 않은 부작용으로 모바일 사용자에게 이제 데스크톱 버전의 웹사이트가 제공됩니다.
SysOps 관리자는 이 문제를 해결하기 위해 어떤 조치를 취해야 합니까?

A. CloudFront 배포 동작을 구성하여 User-Agent 헤더를 전달합니다.
B. CloudFront 배포 오리진 설정을 구성합니다. 오리진 사용자 지정 헤더 목록에 User-Agent 헤더를 추가합니다.
C. ALB에서 IPv6를 활성화합니다. CloudFront 배포 원본 설정을 업데이트하여 dualstack 엔드포인트를 사용합니다.
D. CloudFront 배포에서 IPv6를 활성화합니다. Route 53 레코드를 업데이트하여 dualstack 엔드포인트를 사용합니다.


이 문제는 모바일 사용자가 데스크톱 버전의 웹사이트를 받는 문제와 관련이 있습니다. 이를 해결하기 위해서는 CloudFront가 User-Agent 헤더를 올바르게 전달하여 원본 서버가 사용자의 디바이스 유형(모바일, 데스크톱)에 따라 적절한 버전을 제공할 수 있도록 해야 합니다.

정답: A. CloudFront 배포 동작을 구성하여 User-Agent 헤더를 전달합니다.
이유:
User-Agent 헤더는 사용자가 모바일 기기인지 데스크톱 기기인지 등을 서버에 전달하는 중요한 정보입니다. CloudFront가 기본적으로 일부 헤더를 캐시하여 성능을 최적화하는데, User-Agent 헤더가 전달되지 않으면 원본 서버는 디바이스를 구분할 수 없고, 디바이스에 맞는 적절한 콘텐츠를 제공하지 못할 수 있습니다.
CloudFront 배포에서 User-Agent 헤더를 전달하면, 원본 서버(이 경우 Application Load Balancer 뒤의 Amazon EC2 인스턴스)는 각 디바이스 유형에 맞는 콘텐츠를 적절하게 반환할 수 있습니다.
다른 옵션들은 다음과 같은 이유로 적합하지 않습니다:

B: 오리진 사용자 지정 헤더 목록에 User-Agent를 추가하는 것은 일반적으로 캐시 구성을 제어하는 데 사용되지 않으며, 단순히 오리진으로 헤더를 추가하는 것만으로는 문제를 해결할 수 없습니다.
C와 D: IPv6를 활성화하는 것은 네트워크 수준에서 트래픽을 처리하는 방식일 뿐, 모바일과 데스크톱 사용자 간의 웹사이트 버전 문제와는 직접적인 관련이 없습니다.

### 질문 #4주제 1
SysOps 관리자가 AWS 계정에서 AWS CloudTrail을 활성화했습니다. 

CloudTrail이 비활성화된 경우 즉시 다시 활성화해야 합니다.
SysOps 관리자는 사용자 지정 코드를 작성하지 않고도 이러한 요구 사항을 충족하기 위해 무엇을 해야 합니까?

A. AWS 계정을 AWS Organizations에 추가합니다. 관리 계정에서 CloudTrail을 활성화합니다.
B. CloudTrail 구성이 변경될 때 호출되는 AWS Config 규칙을 만듭니다. AWS-ConfigureCloudTrailLogging 자동 수정 작업을 적용합니다. 가장 많이 투표된
C. CloudTrail 구성이 변경될 때 호출되는 AWS Config 규칙을 만듭니다. CloudTrail을 활성화하기 위해 AWS Lambda 함수를 호출하도록 규칙을 구성합니다.
D. AWS Systems Manager Automation 문서를 실행하고 CloudTrail을 활성화하기 위한 일정 패턴을 사용하여 Amazon EventBridge(Amazon CloudWatch Event) 시간별 규칙을 만듭니다.


SysOps 관리자가 AWS CloudTrail이 비활성화될 때 자동으로 다시 활성화되도록 하려면, 사용자 지정 코드를 작성하지 않고 AWS에서 제공하는 자동화된 솔루션을 사용할 수 있습니다.

정답: B. CloudTrail 구성이 변경될 때 호출되는 AWS Config 규칙을 만듭니다. AWS-ConfigureCloudTrailLogging 자동 수정 작업을 적용합니다.
이유:
AWS Config는 AWS 리소스 구성을 추적하고 모니터링하는 서비스로, CloudTrail과 같은 리소스의 구성이 변경되었을 때 규칙을 트리거할 수 있습니다.
AWS-ConfigureCloudTrailLogging 자동 수정 작업을 적용하면 CloudTrail이 비활성화되었을 때 자동으로 다시 활성화됩니다. 이 자동화된 작업은 사용자 정의 코드 없이도 CloudTrail 구성을 보장할 수 있는 매우 효율적인 방법입니다.
이 방법은 AWS에서 제공하는 기본 기능을 활용하므로 관리가 쉽고 확장 가능합니다.
다른 옵션들은 다음과 같은 이유로 적합하지 않습니다:

A: AWS Organizations의 관리 계정에서 CloudTrail을 활성화할 수 있지만, 이 방법은 비활성화된 CloudTrail을 자동으로 다시 활성화하는 요구 사항을 충족하지 않습니다.
C: Lambda 함수를 사용하는 방법도 가능하지만, 사용자 지정 코드를 작성해야 하므로 더 복잡하고 운영 오버헤드가 증가합니다.
D: EventBridge 시간별 규칙을 사용하면 주기적으로 CloudTrail을 활성화할 수 있지만, CloudTrail이 비활성화된 시점을 즉시 감지하여 다시 활성화하는 데는 적합하지 않습니다. Config 규칙을 사용하는 것이 더 효율적입니다.

### 질문 #5주제 1
한 회사가 Application Load Balancer 뒤의 Amazon EC2 인스턴스에서 웹사이트를 호스팅합니다. 

이 회사는 Amazon Route 53으로 DNS를 관리하고 도메인의 존 에이펙스를 웹사이트로 가리키고 싶어합니다.
이러한 요구 사항을 충족하려면 어떤 유형의 레코드를 사용해야 합니까?

A. 도메인의 존 정점에 대한 AAAA 레코드
B. 도메인의 영역 정점에 대한 A 레코드
C. 도메인의 존 정점에 대한 CNAME 레코드
D. 도메인의 존 정점에 대한 별칭 레코드 가장 많이 투표된

도메인의 존 에이펙스(Apex, 즉 example.com와 같은 최상위 도메인)를 Application Load Balancer(ALB)에 연결하려면, CNAME 레코드는 사용할 수 없습니다. 대신 Amazon Route 53에서 제공하는 별칭(Alìas) 레코드를 사용하는 것이 적합합니다.

정답: D. 도메인의 존 정점에 대한 별칭 레코드
이유:
**별칭 레코드(Alìas Record)**는 Route 53에서 제공하는 기능으로, 특정 AWS 리소스(예: Application Load Balancer, CloudFront 배포, S3 버킷 등)로 도메인을 연결할 수 있습니다.
도메인의 존 에이펙스에는 CNAME 레코드를 사용할 수 없으므로, 별칭 레코드가 가장 적합한 선택입니다. 별칭 레코드는 또한 A 레코드와 유사하게 작동하여 IP 주소로의 변환을 처리합니다.
별칭 레코드는 Route 53이 제공하는 자동화된 기능을 활용해 트래픽 라우팅을 효율적으로 관리하며, 비용도 발생하지 않습니다.
다른 옵션들은 다음과 같은 이유로 적합하지 않습니다:

A: AAAA 레코드는 IPv6 주소를 가리키는 레코드입니다. ALB와 같은 AWS 리소스와 연결하는 데 일반적으로 사용되지 않습니다.
B: A 레코드는 IP 주소를 직접 가리키는 레코드로, AWS 리소스와 동적으로 연결할 수 없습니다.
C: CNAME 레코드는 존 정점(최상위 도메인)에 사용할 수 없으며, 하위 도메인(예: www.example.com)에서만 사용할 수 있습니다.

### 질문 #6주제 1
회사는 S3 버킷에 업로드된 모든 객체가 암호화되도록 해야 합니다.

다음 중 어떤 조치가 이 요구 사항을 충족할까요? (두 가지를 선택하세요.)

A. S3 버킷에 저장된 암호화되지 않은 객체로부터 보호하기 위해 AWS Shield를 구현합니다.
B. 암호화되지 않은 객체가 S3 버킷에 업로드되는 것을 거부하기 위해 객체 액세스 제어 목록(ACL)을 구현합니다.
C. Amazon S3 기본 암호화를 구현하여 업로드되는 모든 객체가 저장되기 전에 암호화되도록 합니다.
D. Amazon Inspector를 구현하여 S3 버킷에 업로드된 객체가 암호화되었는지 검사합니다.
E. 암호화되지 않은 객체가 버킷에 업로드되는 것을 거부하기 위해 S3 버킷 정책을 구현합니다.

Amazon S3 버킷에 업로드된 모든 객체가 암호화되도록 보장하기 위해서는 두 가지 방법을 사용할 수 있습니다: S3 기본 암호화와 버킷 정책을 통한 암호화 강제 적용입니다.

정답:
C. Amazon S3 기본 암호화를 구현하여 업로드되는 모든 객체가 저장되기 전에 암호화되도록 합니다.
E. 암호화되지 않은 객체가 버킷에 업로드되는 것을 거부하기 위해 S3 버킷 정책을 구현합니다.
이유:
C: Amazon S3 기본 암호화를 설정하면 모든 객체가 업로드될 때 자동으로 암호화됩니다. 기본 암호화는 객체가 저장되기 전에 암호화되므로, 사용자가 별도의 암호화 설정을 하지 않더라도 모든 객체가 보호됩니다.
E: S3 버킷 정책을 통해 특정 조건을 강제할 수 있습니다. 예를 들어, 객체가 업로드될 때 반드시 암호화 헤더가 포함되도록 요구하는 정책을 설정할 수 있으며, 이를 따르지 않는 업로드는 자동으로 거부됩니다. 이 방식은 S3 기본 암호화와 함께 사용될 때 더욱 효과적입니다.
다른 옵션들은 적합하지 않은 이유:
A: AWS Shield는 DDoS(분산 서비스 거부) 공격으로부터 보호하기 위한 서비스이며, 객체 암호화와는 관련이 없습니다.
B: 객체 ACL은 객체에 대한 읽기 및 쓰기 권한을 제어하는 것이며, 암호화 여부와 관련이 없습니다.
D: Amazon Inspector는 EC2 인스턴스, 컨테이너 이미지 등의 취약성을 검사하는 서비스로, S3 버킷 객체의 암호화 여부를 검사하는 기능은 제공하지 않습니다.


### 질문 #7주제 1
한 회사에는 Auto Scaling 그룹의 Amazon EC2 인스턴스에 호스팅된 상태 저장 웹 애플리케이션이 있습니다. 

인스턴스는 단일 대상 그룹이 있는 Application Load Balancer(ALB) 뒤에서 실행됩니다. ALB는 Amazon CloudFront 배포에서 원점으로 구성됩니다. 사용자는 웹 애플리케이션에서 무작위 로그아웃을 보고합니다.
SysOps 관리자는 이 문제를 해결하기 위해 어떤 조치 조합을 취해야 합니까? (두 가지를 선택하세요.)

A. ALB 대상 그룹에서 가장 덜 처리된 요청 알고리즘으로 변경합니다.
B. CloudFront 배포 캐시 동작에서 쿠키 전달을 구성합니다.
C. CloudFront 배포 캐시 동작에서 헤더 전달을 구성합니다.
D. ALB 리스너 규칙에서 그룹 수준의 고정성을 활성화합니다.
E. ALB 대상 그룹에서 스티키 세션을 활성화합니다.

무작위 로그아웃 문제는 세션이 EC2 인스턴스 간에 적절하게 유지되지 않기 때문에 발생할 수 있습니다. 특히 상태 저장 애플리케이션에서 세션 관리가 중요한데, 이는 스티키 세션(Sticky Session) 또는 세션 고정성을 통해 해결할 수 있습니다. 또한, CloudFront가 세션 관련 정보를 캐시하지 않도록 해야 합니다.

정답:
B. CloudFront 배포 캐시 동작에서 쿠키 전달을 구성합니다.
E. ALB 대상 그룹에서 스티키 세션을 활성화합니다.
이유:
B. CloudFront 배포 캐시 동작에서 쿠키 전달을 구성합니다.

웹 애플리케이션이 세션 쿠키를 사용하여 사용자를 인증하고 세션을 유지한다면, CloudFront가 쿠키를 전달하지 않으면 세션 상태가 손실될 수 있습니다. CloudFront 배포에서 쿠키 전달을 구성하면, CloudFront가 세션 관련 정보를 제대로 처리하고 사용자에게 무작위 로그아웃 문제가 발생하지 않도록 할 수 있습니다.
E. ALB 대상 그룹에서 스티키 세션을 활성화합니다.

스티키 세션(세션 고정성)을 활성화하면 사용자가 동일한 EC2 인스턴스에 지속적으로 연결됩니다. 이는 상태 저장 애플리케이션에서 사용자의 세션 상태를 유지하는 데 필수적입니다. 스티키 세션을 활성화하면 특정 사용자가 같은 인스턴스로 계속 연결되므로 세션이 유지됩니다.
다른 옵션들은 적합하지 않은 이유:
A: 덜 처리된 요청 알고리즘으로 변경하는 것은 트래픽을 분산시키는 방법일 뿐, 세션 관련 문제 해결과는 관련이 없습니다.
C: 헤더 전달은 쿠키 전달보다 덜 중요하며, 헤더가 세션 문제에 직접적인 영향을 미치지 않을 수 있습니다.
D: 그룹 수준의 고정성은 특정 리스너 규칙에 의존하는 것이며, 대상 그룹의 세션 고정성 관리와는 무관합니다. ALB 대상 그룹의 스티키 세션 설정이 더 적합한 해결책입니다.

### 질문 #8주제 1
한 회사가 AWS Lambda에서 서버리스 애플리케이션을 실행하고 있습니다. 

이 애플리케이션은 Amazon RDS for MySQL DB 인스턴스에 데이터를 저장합니다. 사용량이 꾸준히 증가했고, 최근 Lambda 함수가 데이터베이스에 연결을 시도할 때 "연결이 너무 많음" 오류가 많이 발생했습니다. 이 회사는 이미 가능한 최대 max_connections 값을 사용하도록 데이터베이스를 구성했습니다.
SysOps 관리자는 이러한 오류를 해결하기 위해 무엇을 해야 합니까?

A. 데이터베이스의 읽기 복제본을 만듭니다. Amazon Route 53을 사용하여 두 데이터베이스를 모두 포함하는 가중 DNS 레코드를 만듭니다.
B. Amazon RDS Proxy를 사용하여 프록시를 만듭니다. Lambda 함수에서 연결 문자열을 업데이트합니다.
C. 데이터베이스가 사용하는 매개변수 그룹의 max_connect_errors 매개변수 값을 늘립니다.
D. Lambda 함수의 예약된 동시성을 더 높은 값으로 업데이트합니다.

Lambda 함수가 데이터베이스에 연결을 시도할 때 "연결이 너무 많음" 오류가 발생하는 문제는 데이터베이스 연결 수가 제한된 상황에서 흔히 발생하는 문제입니다. 이 문제를 해결하기 위해 Amazon RDS Proxy를 사용하는 것이 가장 적합한 방법입니다.

정답:
B. Amazon RDS Proxy를 사용하여 프록시를 만듭니다. Lambda 함수에서 연결 문자열을 업데이트합니다.
이유:
Amazon RDS Proxy는 데이터베이스 연결을 관리하여 여러 Lambda 함수가 데이터베이스에 동시에 연결하는 문제를 완화시켜줍니다. 프록시는 연결을 풀링(pooling)하여 Lambda 함수가 데이터베이스와 직접 연결하지 않고 프록시를 통해 연결을 관리함으로써 데이터베이스에 대한 연결 수를 줄일 수 있습니다. 이렇게 하면 데이터베이스에 대한 연결이 최적화되고, "연결이 너무 많음" 오류를 방지할 수 있습니다.
다른 옵션들이 적합하지 않은 이유:
A: 읽기 복제본을 만들고 Route 53 가중 DNS 레코드를 설정하는 것은 읽기 요청 분산에 적합하지만, 이 문제는 연결 수에 관련된 문제이므로 해결책이 되지 않습니다.
C: max_connect_errors 매개변수는 데이터베이스의 연결 시도 오류 허용 한도를 제어하는 매개변수로, 연결 수 제한 문제를 해결하지는 못합니다.
D: Lambda 함수의 동시성을 증가시키는 것은 Lambda 함수가 실행되는 빈도나 동시성을 조절하는 것이며, 이는 데이터베이스 연결 수 문제와 직접적으로 관련이 없습니다. 오히려 더 많은 동시성이 더 많은 연결을 생성할 수 있어 문제가 악화될 수 있습니다.
RDS Proxy는 연결 관리 문제를 해결하는 가장 적절한 방법입니다.

### 질문 #9주제 1
SysOps 관리자가 10개의 Amazon EC2 인스턴스에 애플리케이션을 배포하고 있습니다. 

애플리케이션은 고가용성이어야 합니다. 인스턴스는 별도의 기본 하드웨어에 배치되어야 합니다.
SysOps 관리자는 이러한 요구 사항을 충족하기 위해 무엇을 해야 합니까?

A. 단일 AWS 지역의 클러스터 배치 그룹으로 인스턴스를 시작합니다.
B. 여러 AWS 지역의 파티션 배치 그룹으로 인스턴스를 시작합니다.
C. 여러 AWS 지역에 분산된 배치 그룹으로 인스턴스를 시작합니다.
D. 단일 AWS 지역의 분산된 배치 그룹으로 인스턴스를 시작합니다.

애플리케이션이 고가용성을 요구하고, 인스턴스가 별도의 기본 하드웨어에 배치되어야 한다면, 분산된 배치 그룹을 사용하는 것이 적합합니다. 분산된 배치 그룹은 인스턴스가 서로 다른 물리적 하드웨어에 배치되도록 보장하며, 장애를 격리하는 데 효과적입니다.

정답:
D. 단일 AWS 지역의 분산된 배치 그룹으로 인스턴스를 시작합니다.
이유:
분산된 배치 그룹은 EC2 인스턴스를 서로 다른 물리적 하드웨어에 배치하여 단일 하드웨어 장애가 여러 인스턴스에 영향을 미치지 않도록 설계되었습니다. 따라서 고가용성을 보장하면서 인스턴스가 서로 다른 기본 하드웨어에 배치됩니다.
이 옵션은 단일 AWS 지역에서 고가용성을 유지하기 위한 적절한 선택입니다.
다른 옵션들이 적합하지 않은 이유:
A. 클러스터 배치 그룹은 저지연 네트워크 통신을 위해 인스턴스를 물리적으로 가까운 위치에 배치하는 방식으로, 하드웨어 중복성과 고가용성 요구사항에는 적합하지 않습니다.
B. 여러 AWS 지역의 파티션 배치 그룹은 지역 간 배포를 의미하지만, 파티션 배치 그룹은 특정 리소스 간의 장애 격리에 중점을 둡니다. 또한 다수의 지역을 사용할 필요는 없습니다.
C. 여러 AWS 지역에 분산된 배치 그룹은 고가용성을 위해 지역 간 배포를 의미하지만, 다중 지역 배포는 복잡성을 증가시키며 질문에서 요구하는 것은 단일 지역 내에서의 고가용성입니다.
따라서 단일 AWS 지역의 분산된 배치 그룹이 요구 사항을 충족하는 가장 적합한 선택입니다.

### 질문 #10주제 1
SysOps 관리자가 여러 Amazon EC2 인스턴스가 생성되는 AWS CloudFormation 템플릿의 문제를 해결하고 있습니다. 

템플릿은 us-east-1에서 작동하지만 us-west-2에서는
AMI [ami-12345678]이 존재하지 않음 이라는 오류 코드와 함께 실패합니다.
관리자는 AWS CloudFormation 템플릿이 모든 지역에서 작동하는지 어떻게 확인해야 합니까?

A. 소스 지역의 Amazon Machine Image(AMI)를 대상 지역에 복사하고 동일한 ID를 할당합니다.
B. AWS CloudFormation 템플릿을 편집하여 정규화된 AMI ID의 일부로 지역 코드를 지정합니다.
C. AWS::EC2::AMI::ImageID 컨트롤을 사용하여 AWS CloudFormation 템플릿을 편집하여 사용자에게 모든 AMI의 드롭다운 목록을 제공합니다.
D. "매핑" 섹션에 AMI ID를 포함하여 AWS CloudFormation 템플릿을 수정합니다. 적절한 AMI ID에 대한 템플릿 내의 적절한 매핑을 참조하세요.

이 문제는 특정 지역에서 사용 가능한 AMI가 다르기 때문에 발생합니다. 각 AWS 리전에서 고유한 AMI ID가 있으므로, 모든 지역에서 AWS CloudFormation 템플릿이 작동하도록 하려면 지역별로 다른 AMI ID를 지정할 수 있는 방법을 사용해야 합니다. 이를 위해 AWS CloudFormation 템플릿의 매핑 섹션을 사용하여 지역마다 올바른 AMI ID를 참조하게 할 수 있습니다.

정답:
D. "매핑" 섹션에 AMI ID를 포함하여 AWS CloudFormation 템플릿을 수정합니다. 적절한 AMI ID에 대한 템플릿 내의 적절한 매핑을 참조하세요.
이유:
매핑(Mappings) 섹션은 AWS CloudFormation에서 리전 또는 다른 조건에 따라 값을 달리 지정할 수 있게 해줍니다. 각 리전에 맞는 AMI ID를 매핑에 정의하고, Fn::FindInMap 함수로 적절한 값을 참조하도록 수정하면 템플릿이 여러 리전에서 작동하도록 할 수 있습니다.

예시 매핑 코드:
```yaml

Mappings:
  RegionMap:
    us-east-1:
      AMI: ami-12345678
    us-west-2:
      AMI: ami-87654321

Resources:
  MyEC2Instance:
    Type: "AWS::EC2::Instance"
    Properties:
      ImageId: !FindInMap [RegionMap, !Ref "AWS::Region", AMI]
```      
다른 옵션들이 적합하지 않은 이유:
A: 소스 지역의 AMI를 복사하고 동일한 ID를 할당하는 것은 불가능합니다. AWS에서는 AMI를 복사할 수 있지만, 복사된 AMI는 다른 리전에서 새로운 ID를 갖게 되므로 동일한 ID를 사용할 수 없습니다.
B: CloudFormation 템플릿에서 지역 코드에 따라 정규화된 AMI ID를 지정하는 방식은 존재하지 않습니다. AMI ID는 리전별로 고유합니다.
C: AWS::EC2::AMI::ImageID라는 리소스 타입은 존재하지 않으며, 사용자에게 AMI 목록을 제공하는 기능도 없습니다.
따라서 매핑을 통해 리전별 AMI ID를 설정하는 D 옵션이 가장 적합한 해결책입니다.


### 질문 #11주제 1
SysOps 관리자가 여러 Amazon EC2 인스턴스에서 공유 스토리지를 제공하기 위해 Amazon Elastic File System(Amazon EFS) 파일 시스템을 프로비저닝하고 있습니다. 인스턴스는 모두 여러 가용 영역에 걸쳐 동일한 VPC에 있습니다. 각 가용 영역에는 두 개의 인스턴스가 있습니다. SysOps 관리자는 가능한 가장 낮은 지연 시간으로 각 인스턴스에서 파일 시스템에 액세스할 수 있도록 해야 합니다.
어떤 솔루션이 이러한 요구 사항을 충족할까요?

A. VPC에서 EFS 파일 시스템에 대한 마운트 대상을 만듭니다. 마운트 대상을 사용하여 각 인스턴스에서 파일 시스템을 마운트합니다.
B. VPC의 한 가용성 영역에 EFS 파일 시스템에 대한 마운트 대상을 만듭니다. 마운트 대상을 사용하여 해당 가용성 영역의 인스턴스에 파일 시스템을 마운트합니다. 다른 인스턴스와 디렉토리를 공유합니다.
C. 각 인스턴스에 대한 마운트 대상을 만듭니다. 각 마운트 대상을 사용하여 각 인스턴스에 EFS 파일 시스템을 마운트합니다.
D. VPC의 각 가용성 영역에 마운트 대상을 만듭니다. 마운트 대상을 사용하여 해당 가용성 영역의 인스턴스에 EFS 파일 시스템을 마운트합니다.


주어진 요구 사항에 따라 Amazon Elastic File System (EFS) 파일 시스템에 대한 최적의 솔루션을 선택해야 합니다. 이 경우, 모든 Amazon EC2 인스턴스가 여러 가용 영역에 걸쳐 동일한 VPC에 있으므로 각 인스턴스에서 가능한 가장 낮은 지연 시간으로 EFS에 액세스할 수 있도록 해야 합니다.

정답: **D.VPC의 각 가용성 영역에 마운트 대상을 만듭니다. 마운트 대상을 사용하여 해당 가용성 영역의 인스턴스에 EFS 파일 시스템을 마운트합니다.**

이유:
- EFS는 여러 가용 영역에 걸쳐서 고가용성과 내구성을 제공할 수 있습니다.
- 각 가용 영역에 마운트 대상을 만들면, 해당 가용 영역의 인스턴스가 EFS 파일 시스템에 직접적으로 연결되어 가장 낮은 지연 시간으로 액세스할 수 있습니다.
- 마운트 대상을 각 가용 영역에 설정하면, 네트워크 지연을 최소화하고 각 인스턴스가 EFS 파일 시스템에 효과적으로 접근할 수 있습니다.

다른 옵션들은 다음과 같은 이유로 적합하지 않습니다:
- **A**: 모든 인스턴스가 단일 마운트 대상을 사용할 경우, 네트워크 지연이 발생할 수 있습니다.
- **B**: 한 가용 영역에만 마운트 대상을 두면 다른 가용 영역의 인스턴스에서 높은 지연 시간으로 EFS에 액세스해야 합니다.
- **C**: 각 인스턴스에 대해 별도의 마운트 대상을 만드는 것은 비효율적이며, EFS의 이점을 제대로 활용하지 못합니다.


### 질문 #12주제 1
SysOps 관리자가 AWS CloudFormation 템플릿을 사용하여 VPC를 성공적으로 배포했습니다. SysOps 관리자는 AWS Organizations를 통해 관리되는 여러 계정에 동일한 템플릿을 배포하려고 합니다.
어떤 솔루션이 가장 적은 운영 오버헤드로 이 요구 사항을 충족할까요?

A. 관리 계정에서 OrganizationAccountAccessRole IAM 역할을 맡습니다. 각 계정에 템플릿을 배포합니다.
B. 각 계정에서 역할을 맡을 AWS Lambda 함수를 만듭니다. AWS CloudFormation CreateStack API 호출을 사용하여 템플릿을 배포합니다.
C. 계정 목록을 쿼리하기 위한 AWS Lambda 함수를 만듭니다. AWS CloudFormation CreateStack API 호출을 사용하여 템플릿을 배포합니다.
D. 관리 계정의 AWS CloudFormation StackSets를 사용하여 각 계정에 템플릿을 배포합니다.


주어진 시나리오에서 SysOps 관리자가 AWS CloudFormation 템플릿을 여러 AWS Organizations 계정에 배포하려고 할 때, 가장 적은 운영 오버헤드로 이 요구 사항을 충족할 수 있는 솔루션은 다음과 같습니다.

정답: **D. 관리 계정의 AWS CloudFormation StackSets를 사용하여 각 계정에 템플릿을 배포합니다.**

이유:
- **AWS CloudFormation StackSets**를 사용하면 여러 AWS 계정 및 리전에서 CloudFormation 스택을 동시에 관리하고 배포할 수 있습니다. 
- StackSets를 사용하면 단일 템플릿을 기반으로 여러 계정에 변경 사항을 쉽게 적용할 수 있으며, 중앙에서 관리하므로 운영 오버헤드가 줄어듭니다.
- 또한, StackSets는 IAM 권한과 관련하여 각 계정에 적절한 역할을 자동으로 처리할 수 있어 관리가 용이합니다.

다른 옵션들은 다음과 같은 이유로 적합하지 않습니다:
- **A**: 역할을 맡아 개별적으로 템플릿을 배포하는 것은 운영 오버헤드가 크고 관리가 복잡합니다.
- **B**: 각 계정에서 Lambda 함수를 만들어야 하며, 관리해야 할 코드가 많아져 운영 오버헤드가 증가합니다.
- **C**: 계정 목록을 쿼리하는 Lambda 함수를 만드는 것은 여전히 복잡성을 증가시키고, 여러 계정에 대해 수동으로 API 호출을 해야 하므로 비효율적입니다.

### 질문 #13주제 1
한 회사에서 계산을 위해 20개의 Amazon EC2 인스턴스로 구성된 플릿을 관리하기 위해 분산 컴퓨팅 소프트웨어를 실행하고 있습니다. 

플릿에는 계산을 실행하기 위한 2개의 제어 노드와 18개의 작업 노드가 포함되어 있습니다. 제어 노드는 자동으로 작업 노드를 시작할 수 있습니다.
현재 모든 노드는 주문형으로 실행됩니다. 제어 노드는 주 7일, 하루 24시간 이용 가능해야 합니다. 작업 노드는 매일 4시간씩 실행됩니다. SysOps 관리자는 이 솔루션의 비용을 최적화해야 합니다.
이러한 요구 사항을 충족하는 작업의 조합은 무엇입니까? (두 가지를 선택하세요.)

A. 제어 노드에 대한 EC2 인스턴스 절약 플랜을 구매합니다. 가장 많이 투표된
B. 제어 노드에 전용 호스트를 사용합니다.
C. 작업 노드에 예약 인스턴스를 사용합니다.
D. 제어 노드에 Spot Instances를 사용합니다. Spot 가용성이 없는 경우 On-Demand Instances를 사용합니다.
E. 작업 노드에 Spot 인스턴스를 사용합니다. Spot 가용성이 없는 경우 On-Demand 인스턴스를 사용합니다. 가장 많이 투표된




### 질문 #14주제 1
회사는 Amazon S3 버킷에서 매 시간 데이터 파일을 수신해야 합니다. 

S3 이벤트 알림은 파일이 도착할 때마다 AWS Lambda 함수를 호출합니다. 이 함수는 애플리케이션에서 사용할 수 있도록 데이터를 처리합니다.
애플리케이션 팀은 때때로 파일이 도착하지 않는다는 것을 알아차립니다. 애플리케이션 팀은 파일이 도착하지 않을 때마다 알림을 받고 싶어합니다.
이러한 요구 사항을 충족하는 가장 운영 효율적인 솔루션은 무엇입니까?

A. 지난 1시간 동안 생성된 객체로 제한된 범위로 S3 버킷에 S3 수명 주기 규칙을 추가합니다. 전환된 객체 수가 0일 때 수명 주기 전환에 의해 호출되는 다른 S3 이벤트 알림을 구성합니다. Amazon Simple Notification Service(Amazon SNS) 토픽에 메시지를 게시하여 애플리케이션 팀에 알립니다.
B. Amazon Simple Queue Service(Amazon SQS) 대기열에 메시지를 게시하는 Lambda 함수를 호출하도록 다른 S3 이벤트 알림을 구성합니다. 대기열의 ApproximateAgeOfOldestMessage 메트릭이 1시간보다 클 때 애플리케이션 팀에 알리기 위해 Amazon Simple Notification Service(Amazon SNS) 토픽에 메시지를 게시하는 Amazon CloudWatch 알람을 만듭니다.
C. Lambda 함수의 Invocations 메트릭이 1시간 동안 0일 때 애플리케이션 팀에 경고하기 위해 Amazon Simple Notification Service(Amazon SNS) 토픽에 메시지를 게시하는 Amazon CloudWatch 알람을 만듭니다. 누락된 데이터를 위반으로 처리하도록 알람을 구성합니다. 가장 많이 투표된
D. S3 버킷에서 가장 최신 파일의 타임스탬프를 가져오는 새 Lambda 함수를 만듭니다. 타임스탬프가 1시간 전이면 Amazon Simple Notification Service(Amazon SNS) 토픽에 메시지를 게시하여 애플리케이션 팀에 알립니다. 매시간 새 함수를 호출하는 Amazon EventBridge(Amazon CloudWatch Events) 규칙을 만듭니다.

가장 운영 효율적인 솔루션은 옵션 C입니다.

C. Lambda 함수의 Invocations 메트릭이 1시간 동안 0일 때 애플리케이션 팀에 경고하기 위해 Amazon Simple Notification Service(Amazon SNS) 토픽에 메시지를 게시하는 Amazon CloudWatch 알람을 만듭니다. 누락된 데이터를 위반으로 처리하도록 알람을 구성합니다.

이 솔루션은 다음과 같은 이유로 적합합니다:

운영 효율성: Lambda 함수의 Invocations 메트릭을 사용해 파일이 도착하지 않을 때 알림을 받을 수 있습니다. Lambda 함수가 호출되지 않으면 알림이 생성되므로 추가적인 커스텀 코드를 작성할 필요가 없습니다.
간단한 구성: AWS Lambda와 CloudWatch는 이미 설정된 메트릭을 기반으로 경고를 설정할 수 있으므로 추가적인 구성이나 복잡한 시스템 모니터링을 필요로 하지 않습니다.
자동화된 알림: Lambda가 호출되지 않는 상황을 바로 감지하여 SNS를 통해 알림을 받을 수 있습니다.
다른 옵션들에 비해 이 방법이 가장 직관적이고 관리하기 쉬운 방식입니다.


### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



### 



